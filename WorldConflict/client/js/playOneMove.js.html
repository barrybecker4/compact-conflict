<script>
var erisk = (function(my) {
    const $ = domUtils.$;
    const SERVER_REQUEST_DELAY = 2000;
    let localHumanMoves = [];

    /** Deals with responding to user actions - whether human or AI. */
    my.playOneMove = function(state, afterUndo) {
        if (!appState.isInGame())
            return; // game terminated

        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {

            const player = state.activePlayer();

            if (player.name === domUtils.userid()) {
                getMovesForCurrentPlayer(player, state, afterUndo);
            }
            else {
                persistLocalMovesIfAny(() => {
                    if (player.personality) {
                        erisk.setPreviousState(null); // only humans can undo
                        // request that the server make the AI moves (and store it in firestore),
                        google.script.run
                            .withFailureHandler(showError)
                            // must wrap state in array to make GAS happy (don't know why)
                            .makeAiMovesOnServer([state], gameData.getSimpleObject());
                    }
                });

                // Request from server whatever human or AI moves were made since last request.
                setTimeout(() => replayMovesFromServer(state), SERVER_REQUEST_DELAY);
            }

            erisk.gameRenderer.updateDisplay(state);
        });
    }

    /** This just stores the players move(s) in localHumanMoves since, because of undo,
     * it's not final, until "end move" is clicked.
     */
    function getMovesForCurrentPlayer(player, state, afterUndo) {
        erisk.uiPickMove(player, state, function(move) {
            const newState = erisk.makeMove(state, move);
            move.stateId = newState.id;
            move.gameId = newState.gameId;
            console.log("applying cp-move with stateId: " + move.stateId + " to " + state.id + " to give " + newState.id);

            if (afterUndo) {
                localHumanMoves.pop();
            }
            localHumanMoves.push(move);

            if (newState.endResult) { // did the game end?
                showEndGame(newState);
            } else {
                erisk.setPreviousState(state.copy()); // only humans can undo
                setTimeout(() => my.playOneMove(newState), 0); // recursive call
            }
        });
    }

    function persistLocalMovesIfAny(callback) {
        if (localHumanMoves.length) {
            console.log("asking server to append moves: " + localHumanMoves.map(m => m.stateId));
            google.script.run
                .withSuccessHandler(callback)
                .withFailureHandler(showError)
                .appendGameMoves(localHumanMoves);
            localHumanMoves = [];
        } else {
            callback();
        }
    }

    function replayMovesFromServer(state) {
        console.log("Requesting replay moves from server starting at state.id = " + state.id);
        google.script.run
            .withSuccessHandler(getPlaybackHandler(state))
            .withFailureHandler(showError)
            .getGameMoves(state.gameId, state.id);
    }

    function getPlaybackHandler(startState) {
        return async function(moves) {

            const finalState = await replayMove(0, startState);

            async function replayMove(i, state) {
                if (i >= moves.length) {
                    return state;
                }
                const theMove = moves[i];
                const move = Move.reconstitute(theMove);
                let nextState = erisk.makeMove(state, move);
                console.log("   applying move with stateId: " + theMove.stateId + " to " + state.id + " to give " + nextState.id + "(for " + state.activePlayer().getName() + ")");

                erisk.oneAtaTime(CONSTS.PLAYBACK_DELAY, () => {
                    if (CONSTS.DEBUG) {
                        const name = state.activePlayer().getName();
                        console.log(`${i}) Move found on server for ${name}: ${JSON.stringify(move)}`);
                    }
                    audio.playSound(CONSTS.SOUNDS.CLICK);
                    erisk.gameRenderer.updateDisplay(nextState);
                });
                return await replayMove(i + 1, nextState);
            }

            if (finalState.endResult) {
                showEndGame(finalState);
            }
            else {
                if (finalState.activePlayer().name !== domUtils.userid()) {
                    if (CONSTS.DEBUG) {
                        console.log("activePlayer " + finalState.activePlayer().name +
                            " is not " + domUtils.userid() + " so requesting more moves from sever");
                    }
                    // If we have not yet advanced to the player on this client, request more moves until we do
                    setTimeout(() => replayMovesFromServer(finalState), SERVER_REQUEST_DELAY);
                }
                else setTimeout(() => my.playOneMove(finalState), 0);
            }
        }
    }

    function showEndGame(state) {
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, () => erisk.gameRenderer.updateDisplay(state));
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {
            const winner = state.endResult;
            const delay = 200;
            const duration = 4000;
            if (winner !== CONSTS.DRAWN_GAME) {
                erisk.gameRenderer.showBanner(winner.colorEnd, `${winner.getName()} wins the game!`, delay, duration);
            } else {
                erisk.gameRenderer.showBanner('#333', "The game ends in a draw!", delay, duration);
            }

            erisk.gameRenderer.updateDisplay(state);

            $('turn-count').innerHTML = "Game complete";
            const infoEl = $('info');
            infoEl.innerHTML = domUtils.elem('p', {}, "Click the button below to start a new game.");
            infoEl.style.background = '#555';
            $('move-info').style.display = 'none';
            erisk.gameRenderer.updateButtons([ {text: "New game"} ]);

            persistLocalMovesIfAny(() => {});

            uiCallbacks.setBuildCB(erisk.runSetupScreen);
        });
    }

    return my;
}(erisk || {}));
</script>
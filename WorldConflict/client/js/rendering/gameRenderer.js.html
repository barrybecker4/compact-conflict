<script>
erisk.gameRenderer = (function() {

    const my  = {};
    let soldierDivsById = {};
    const { range, rint, lerp, forEachProperty } = utils;
    const { elem, div, $,  append, onClickOrTap, toggleClass, setTransform } = domUtils;
    const { projectPoint, makePolygon, centerOfWeight, transformPoints } = geomUtils;

    const DEAD_SYMBOL = '&#9760;'; // skull and crossbones - shows when you're dead
    const FAITH_SYMBOL = '&#9775;'; // faith is like money
    const VICTORY_SYMBOL = '&#9819;';
    const REGION_SYMBOL = '&#9733;'; // a star represents a region

    // Initial rendering of the game map (regions) as an SVG object. TODO: split out mapRenderer
    my.showMap = function(container, gameState) {

        // define gradients and clipping paths for rendering
        const defs = elem('defs', {},
                makeClipPaths() +
                erisk.makeGradient('ocean', '#69e', '#48b') +
                erisk.makeGradient('land', '#dcb', '#a98') +
                erisk.makeGradient('land-highlight', '#fb7', '#741') +
                erisk.makeGradient('bottom', '#210', '#000') +
                erisk.makeGradient('shadow', '#55d', '#134') +
                gameData.players.map(function(player, index) {
                    return erisk.makeGradient('p' + index, player.colorStart, player.colorEnd) +
                        erisk.makeGradient('p' + index + '-highlight', player.highlightStart, player.highlightEnd);
                }).join(''));

        // create all the layers (5 per region)
        const ocean = makePolygon(
            [
                { x: 0, y: 0 },
                { x: geomUtils.MAP_WIDTH, y: 0 },
                { x: geomUtils.MAP_WIDTH, y: geomUtils.MAP_HEIGHT },
                { x: 0, y: geomUtils.MAP_HEIGHT }
            ],
            'ocean', 'ocean'
        );
        const tops = makeRegionPolys('region', 'land', 1, 1, 0, 0);
        const bottoms = makeRegionPolys('bottom', 'bottom', 1, 1, .05, .05);
        const shadows = makeRegionPolys('shadow', 'shadow', 1.05, 1.05, .2, .2, ' ');
        const highlighters = makeRegionPolys('highlight', '', 1, 1, 0, 0, 'stroke:#fff;stroke-width:1.5;opacity:0.0;', 'clip');

        // replace the map container contents with the new map
        container.innerHTML = elem('svg', {
            viewbox: '0 0 100 100',
            preserveAspectRatio: 'none'
        }, defs + ocean + shadows + bottoms + tops + highlighters);

        // clean internal structure used to track HTML nodes
        soldierDivsById = {};

        // hook up region objects to their HTML elements
        gameData.regions.map(function(region, index) {
            region.elementId = 'region' + index;
            region.center = projectPoint(centerOfWeight(region.points));

            region.highlightId = 'highlight' + index;
            onClickOrTap($(region.highlightId), event => uiCallbacks.invokeCallback(region, 'regionSelected', event));
        });

        // clears the currently selected region
        onClickOrTap(document.body, event => uiCallbacks.invokeCallback(null, 'regionSelected', event));

        makeTemples();

        // makes clipping paths for the "highlight" polygons
        function makeClipPaths() {
            return gameData.regions.map((region, index) => {
                return elem('clipPath', {i: 'clip' + index}, makePolygon(region.points, 'cp' + index, 'land', ''));
            }).join('');
        }

        // a helper for creating a polygon with a given setup for all regions
        function makeRegionPolys(idPrefix, gradient, xm, ym, xd, yd, stroke, clip) {

            return elem('g', {}, gameData.regions.map((region, index) => {
                const clipRegion = clip ? 'url(#' + clip + index + ')' : '';
                return makePolygon(
                    transformPoints(region.points, xm, ym, xd, yd),
                    idPrefix + index, gradient, stroke, clipRegion
                );
            }).join(''));
        }

        // makes temples, which are just <div>s with nested <div>s (the towers)
        function makeTemples() {
            forEachProperty(gameState.temples, function(temple, i) {
                const center = gameData.regions[temple.regionIndex].center,
                    style = 'left:' + (center.x - 1.5) + '%; top:' + (center.y - 4) + '%';

                const obj = {c: 'temple-level'};
                temple.elementId = 'temple' + i;
                const templeHTML = div({
                    i: temple.elementId,
                    c: 'temple',
                    s: style
                }, div(obj, div(obj, div(obj, div(obj)))));
                const templeElement = append('map', templeHTML);

                onClickOrTap(templeElement, event =>
                    uiCallbacks.invokeCallback(gameData.regions[temple.regionIndex], 'templeSelected', event)
                );
            });
        }
    }

    // Updating the display to match the current game state.
    my.updateMapDisplay = function(gameState) {
        gameData.regions.map(updateRegionDisplay);
        forEachProperty(gameState.temples, updateTempleDisplay);

        const soldiersStillAlive = [];
        forEachProperty(gameState.soldiersByRegion, function(soldiers, regionIndex) {
            soldiers.map((soldier, i) => updateSoldierDisplay(gameData.regions[regionIndex], soldier, i));
        });

        forEachProperty(soldierDivsById, function(div, id) {
            if (soldiersStillAlive.indexOf(parseInt(id)) < 0) {
                // this is an ex-div - in other words, the soldier it represented is dead.
                $('map').removeChild(div);
                // surprisingly, this should be safe to do during iteration - http://stackoverflow.com/a/19564686
                delete soldierDivsById[id];

                spawnSmokeParticles(div)
            }
        });

        updateFloatingText();
        updateTooltips();
        updateSoldierTooltips();

        function updateRegionDisplay(region) {
            const regionIndex = region.index;
            const regionOwner = gameState.owner(region);
            let gradientName = regionOwner ? 'p' + regionOwner.index : 'land';

            // a region is highlighted if it is an available move, or belongs to the winner
            const highlighted = hasAvailableMove(regionIndex, gameState) || isWinnerRegion(regionOwner, gameState);

            if (highlighted) {
                gradientName += '-highlight';
            }
            let highlightedOpacity = 0.1 + region.center.x * 0.003;
            if (gameState.endResult || (gameState.moveDecision && gameState.moveDecision.source === regionIndex))
                highlightedOpacity *= 2;
            const highlightEl = $(region.highlightId);
            highlightEl.style.opacity = highlighted ? highlightedOpacity : '0.0';
            highlightEl.style.cursor = highlighted ? 'pointer' : 'default';

            if (gameState.particleTempleRegion && gameState.particleTempleRegion.index === regionIndex) {
                gameState.particleTempleRegion = undefined;
                spawnCelebratoryParticles(region);
            }

            const regionEl = $(region.elementId);
            regionEl.style.fill = 'url(#' + gradientName + ')';
        }

        function hasAvailableMove(regionIndex, gameState) {
            const highlitRegions = gameState.moveDecision && gameState.moveDecision.highlitRegions || [];
            return sequenceUtils.contains(highlitRegions, regionIndex);
        }

        function isWinnerRegion(regionOwner, gameState) {
            return gameState.endResult && regionOwner && regionOwner.index === gameState.endResult.index;
        }

        function updateTooltips() {
            [].slice.call(document.querySelectorAll('.ttp')).map(el => $('map').removeChild(el));
            if (gameState.activePlayer().personality) return;

            // "how to move" tooltips
            const hasSource = gameState.moveDecision && typeof gameState.moveDecision.source == 'number';
            if (hasSource)  {
                showHowToMoveTips();
            }
            else {
                showConqueringCannotMoveTip();
            }
            if (gameState.turnIndex === 2 && gameState.movesRemaining === 2) {
                showTooltipOver({ center: { x: 90, y: 93 } },
                    "If you want to undo a move or check the rules, use the buttons here.", 15);
            }
        }

        function showHowToMoveTips() {
            const source = gameData.regions[gameState.moveDecision.source];
            showTooltipOver(source, "Click this region again to change the number of soldiers.");
            // pick the furthest neighbor
            const furthestIdx = sequenceUtils.max(source.neighbors, (nbr) => source.centerDistanceFrom(gameData.regions[nbr]));
            showTooltipOver(gameData.regions[furthestIdx], "Click a bordering region to move.");
        }

        function showConqueringCannotMoveTip() {
            const inactiveArmies = gameState.conqueredRegions;
            if (inactiveArmies) {
                showTooltipOver(gameData.regions[inactiveArmies[inactiveArmies.length - 1]],
                    "Armies that conquer a new region cannot move again.");
                showTooltipOver({ center: {x: -2, y: 80} }, "Once you're done, click 'End turn' here.");
            }
        }

        function showTooltipOver(region, text, width) {
            if (storage.gameSetup.firstTimeInstructions[text]) return;
            setTimeout(function() {
                // don't display it again. Timeout used to handle multiple updateDisplays() in a row.
                storage.gameSetup.firstTimeInstructions[text] = 1;
                storage.storeSetup();
            }, 500);

            width = width || 7;
            const left = region.center.x - (width + 1) * 0.5, bottom = 102 - region.center.y;
            const styles = 'bottom: ' + bottom + '%; left: ' + left + '%; width: ' + width + '%';

            append('map', div({c: 'tt ttp', s: styles}, text));
        }

        function updateTempleDisplay(temple) {
            let element = $(temple.elementId);

            // right color and right number of levels (corresponding to upgrade level)
            let templeLevels = temple.upgrade ? (temple.level + 3) : 2;
            while (element) {
                const style = element.style;
                style.display = (templeLevels > 0) ? 'block' : 'none';
                style.background = temple.upgrade ? temple.upgrade.bgColor : '#999';

                templeLevels--;
                element = element.firstChild;
            }

            setTempleCursor(temple, gameState);
        }

        function setTempleCursor(temple, gameState) {
            const templeEl = $(temple.elementId);
            if (templeEl) {
                let activePlayerIsTempleOwner = gameState.isOwnedBy(temple.regionIndex, gameState.activePlayer());
                templeEl.style.cursor = appState.isInGame() ?
                    (activePlayerIsTempleOwner ? 'zoom-in' : 'help') : 'default';

                const selected = gameState.moveDecision && gameState.moveDecision.regionIndex === temple.regionIndex;
                toggleClass(templeEl, 'selected', selected);
            }
        }

        function updateSoldierDisplay(region, soldier, index) {
            // we're still alive, so no removing our <div>
            soldiersStillAlive.push(soldier.i);
            const domElement = findOrCreateSoldierElement(soldier);

            // (re)calculate where the <div> should be
            const center = region.center;
            const totalSoldiers = gameState.soldierCount(region);

            const columnWidth = sequenceUtils.min([totalSoldiers, 4]);
            const rowHeight = sequenceUtils.min([2 / Math.ceil(totalSoldiers / 4), 1]);

            const x = index % 4, y = Math.floor(index / 4);
            const xOffset = (-0.6 * columnWidth + x * 1.2);
            const yOffset = y * rowHeight + (gameState.temples[region.index] ? 1.5 : 0);
            let xPosition = center.x + xOffset - yOffset * 0.2;
            let yPosition = center.y + xOffset * 0.2 + yOffset;

            if (typeof soldier.attackedRegion !== 'undefined') {
                // we're attacking right now - move us closer to target region
                const targetCenter = gameData.regions[soldier.attackedRegion].center;
                xPosition = (xPosition + targetCenter.x) / 2;
                yPosition = (yPosition + targetCenter.y) / 2;
            }
            domElement.style.left = xPosition + '%';
            domElement.style.top  = yPosition + '%';
            domElement.style.zIndex = 20 + y * 5 + x;
            domElement.style.display = 'block';

            const decisionState = gameState.moveDecision || {};
            toggleClass(domElement, 'selected', (decisionState.source === region.index && index < decisionState.count));
        }

        function findOrCreateSoldierElement(soldier) {
            let domElement = soldierDivsById[soldier.i];
            if (!domElement) {
                domElement = createSoldierElement(soldier);
            }
            return domElement;
        }

        function createSoldierElement(soldier) {
            let html = div({c: 'soldier', s: 'display: none'});
            const domElement = append('map', html);
            soldierDivsById[soldier.i] = domElement;
            onClickOrTap(domElement, (event) => uiCallbacks.invokeCallback(soldier, 'soldierSelected', event));
            return domElement;
        }

        function updateSoldierTooltips() {
            gameData.regions.map(function(region, regionIndex) {
                const tooltipId = 'side-control' + regionIndex;
                // delete previous tooltip, if present
                let tooltip = $(tooltipId);

                // should we have a tooltip?
                let count = gameState.soldierCount(region);
                if (count > 8) {
                    const moveSourceIsRegion =
                        (gameState.moveDecision && (gameState.moveDecision.source === region.index));
                    let selected = moveSourceIsRegion ? gameState.moveDecision.count : 0;
                    selected += sequenceUtils.sum(gameState.soldiersAtRegion(regionIndex), function(soldier) {
                        return (typeof soldier.attackedRegion !== 'undefined') ? 1 : 0;
                    });
                    if (selected) {
                        count = selected + "<hr>" + count;
                    }

                    if (!tooltip) {
                        const tooltipHTML = div({
                            i: tooltipId,
                            c: 'tt soldier-tt',
                            s: "left:" + (region.center.x - 1.5) + '%;top:' + (region.center.y + 1.2) + '%'
                        }, '');
                        tooltip = append('map', tooltipHTML);
                    }
                    tooltip.innerHTML = count;
                } else if (tooltip) {
                    tooltip.parentNode.removeChild(tooltip);
                }
            });
        }

        function updateFloatingText() {
            let floaters = gameState.floatingText || [];
            floaters.map(function(floater) {
                let x, y;
                if (typeof floater.regionIdx === 'number') {
                    const region = gameData.regions[floater.regionIdx]
                    x = region.center.x;
                    y = region.center.y;
                } else if (floater.soldier) {
                    const node = soldierDivsById[floater.soldier.i];
                    x = parseFloat(node.style.left) + 0.2;
                    y = parseFloat(node.style.top) + 0.2;
                } else {
                    throw new Error("The floater had neither region, nor soldier:\n" + JSON.stringify(floater));
                }

                x -= floater.width / 2 + 0.5; y -= 4;

                const styles = "left: " + x + "%;top:" + y + "%;color:" +
                    floater.center + ";width:" + floater.width + "%";
                const floatingNode = append('map', div({c: 'tt', s: styles}, floater.text));
                setTransform(floatingNode, "translate3d(0,0,0)");
                floatAway(floatingNode, 0, -3);
            });
            gameState.floatingText = undefined;
        }
    }

    my.updateButtons = function(buttons) {
        $('footer-buttons').innerHTML = '';
        (buttons || []).map(function(button, index) {
            if (button.hidden) return;

            let buttonContents = div({}, button.text);
            if (button.description)
                buttonContents += div({c: 'description'}, button.description);

            let buttonHTML = elem('a', {href: '#', c: button.disabled ? 'off' : ''}, buttonContents);
            const buttonNode = append('footer-buttons', buttonHTML);
            if (!button.disabled) {
                onClickOrTap(buttonNode, (event) => uiCallbacks.invokeCallback(index, 'build', event));
            }
        });
    }

    let displayedState;
    my.updateDisplay = function(gameState) {
        // just for debugging
        if (gameState) {
            displayedState = gameState;
        }

        my.updateMapDisplay(displayedState);
        if (appState.isInGame())
            updateInGameUI(displayedState);

        if (displayedState.soundCue) {
            audio.playSound(displayedState.soundCue);
            displayedState.soundCue = null; // probably not needed
        }
    }

    function updateInGameUI(gameState) {
        const decisionState = gameState.moveDecision;
        const buildingMode = decisionState && decisionState.isBuildMove();
        const movingArmy = decisionState && decisionState.isArmyMove();

        const activePlayer = gameState.activePlayer();

        // turn counter/building name
        const turnCountEl = $('turn-count');
        if (buildingMode) {
            const info = gameState.templeInfo(gameState.templeForRegion(decisionState.regionIndex));
            turnCountEl.innerHTML = div({}, info.name) + div({c: 'description'}, info.description);
        } else {
            turnCountEl.innerHTML =
                'Turn <b>' + gameState.turnIndex + '</b>' +
                ((storage.gameSetup.turnCount !== CONSTS.UNLIMITED_TURNS) ? ' / ' + storage.gameSetup.turnCount : '');
        }

        // player data
        gameData.players.map(function(player, index) {
            $('player-box' + index).className =
                (index === gameState.playerIndex) ? 'player-box active' : 'player-box inactive';
            const hasRegions = gameState.regionCount(player);
            const gameWinner = gameState.endResult;
            const regionCountEl = $('region-count' + index);
            const playerCashEl = $('player-cash' + index);

            if (!regionCountEl) return;

            if (hasRegions) {
                regionCountEl.innerHTML = gameState.regionCount(player) + REGION_SYMBOL;
                if (gameWinner) {
                    playerCashEl.innerHTML = (gameWinner === player) ? VICTORY_SYMBOL : '';
                } else {
                    playerCashEl.innerHTML = gameState.cash[player.index] + FAITH_SYMBOL;
                }
            }
            else {
                regionCountEl.innerHTML = DEAD_SYMBOL;
                playerCashEl.innerHTML = '';
            }
        });

        let moveInfo;
        if (!activePlayer.personality) {
            if (buildingMode) {
                if (gameState.owner(decisionState.regionIndex).index === activePlayer.index)
                    moveInfo = elem('p', {}, 'Choose an upgrade to build.');
                else
                    moveInfo = '';
            } else if (movingArmy) {
                moveInfo = elem('p', {}, 'Click on this region again to choose how many to move.') +
                    elem('p', {}, 'Click on a target region to move the army.');

            } else {

                moveInfo = elem('p', {}, 'Click on a region to move or attack with its army.') +
                    elem('p', {}, 'Click on a temple to buy soldiers or upgrades with &#9775;.');
            }
        } else {
            moveInfo = elem('p', {}, activePlayer.getPlayerName() + ' is taking her turn.');
        }
        const infoEl = $('info');
        infoEl.innerHTML = moveInfo;
        infoEl.style.background = activePlayer.colorEnd;

        // activePlayer stats
        $('pd').style.display =  buildingMode ? 'none' : 'block';
        $('move-count').innerHTML = gameState.movesRemaining + elem('span', {s: 'font-size: 80%'}, '&#10138;');
        $('faith').innerHTML = gameState.cash[activePlayer.index] +  elem('span', {s: 'font-size: 80%'}, '&#9775;');

        // buttons
        my.updateButtons(decisionState && decisionState.buttons);

        // undo
        $('undo-button').innerHTML = erisk.undoEnabled(gameState) ? "&#x21b6;" : "";
    }

    my.showBanner = function(background, text, delay, duration) {
        delay = delay || 1;
        duration = duration || 1600;
        erisk.oneAtaTime(delay, function() {
            // create a new banner div
            let banner = append('container', div({c: 'banner'}, text));
            let styles = banner.style;

            styles.background = background;
            styles.opacity = 0.0;
            setTransform(banner, transform(-1));

            setTimeout(function() {
                styles.opacity = 1.0;
                setTransform(banner, transform(1));
            }, 0.1 * duration);

            setTimeout(function() {
                styles.opacity = 1.0;
            }, 0.5 * duration);

            setTimeout(function() {
                styles.opacity = 0.0;
            }, 0.7 * duration);

            setTimeout(function() {
                banner.parentNode.removeChild(banner);
            }, duration);
        });

        function transform(offset) {
            return "translate3d(10px, " + 20 * offset + "px, 0)";
             // rotateY(" + (8 + offset * 2) + "deg)"; // this doesn't work on Safarr
        }
    }

    function spawnSmokeParticles(div) {
        const x = parseFloat(div.style.left);
        const y = parseFloat(div.style.top);
        const numParticles = 20;
        range(0, numParticles).map(function() {
            const angle = Math.random() * 6.28;
            const dist = rint(0, 200) / 80;
            spawnParticle(x + Math.sin(angle) * dist, y + Math.cos(angle) * dist, 0, -1, '#112');
        });
    }

    function spawnCelebratoryParticles(region) {
        region.points.map(point => {
            point = projectPoint(point);
            const center = region.center;
            const alpha = rint(30, 150) / 100;
            const startPoint = { x: lerp(alpha, center.x, point.x), y: lerp(alpha, center.y, point.y) };
            const vx = (startPoint.x - center.x) / 2;
            const vy = (startPoint.y - center.y) / 2 - 0.15;
            spawnParticle(startPoint.x, startPoint.y, vx, vy, '#fff');
        });
    }

    function spawnParticle(x, y, vx, vy, color) {
        // box-shadow:  x-offset, y-offset, blur radius, spread radius, color
        const styleString = "opacity:1; left: " + x + "%;top: " + y + "%; box-shadow: 0 0 4px 4px " + color;
        const particle = append('map', div({c: 'particle', s: styleString}, ''));
        floatAway(particle, vx, vy);
    }

    function floatAway(elem, vx, vy) {
        setTimeout(function() {
            setTransform(elem, "translate3d(" + vx + "em," + vy + "em,0)");
            elem.style.opacity = 0.0;
        }, 100);
        setTimeout(function() {
            if ($('map').contains(elem))
                $('map').removeChild(elem);
        }, 3050);
    }

    my.preserveAspect = function() {
        setTimeout(function() {
            let w = window.innerWidth;
            let h = window.innerHeight;
            let aspect = 1.65, px = 'px';

            if (w / h > aspect) {
                w = h * aspect;
            } else {
                h = w / aspect;
            }

            const styles = $('container').style;
            styles.width = w + px;
            styles.height = h + px;
            styles.fontSize = 0.0154 * Math.pow(h, 1.07) + px;
        }, 0);
    }

    return my;
}());
</script>

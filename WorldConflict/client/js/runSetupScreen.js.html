<script>
var erisk = (function(my) {
    const { $, div } = domUtils;

    my.runSetupScreen = function() {
        audio.setupAudio();
        appState.setInSetup();

        regenerateGameData(status => {
            // console.log("done making initial gameData status = " + status + " gameId = " + gameData.gameId);
            switch (status) {
                case CONSTS.WAITING_FOR_PLAYERS: doneConfiguring(); break;
                case CONSTS.READY_TO_START: startGame(); break;
            }
        });
        createSetupUI();

        // callback for the buttons on the bottom: new map, or done configuring
        uiCallbacks.setBuildCB(function(whichButton) {
            if (!isSetupValid()) return;
            if (whichButton === 0) { // change map
                regenerateGameData();
            } else if (areOpenSlots()) {
                doneConfiguring();
            } else {
                startGame();
            }
        });

        function areOpenSlots() {
            const reducer = (accumulator, currentValue) => accumulator + (currentValue === CONSTS.PLAYER_HUMAN_OPEN ? 1 : 0);
            const numOpen = storage.gameSetup.playerTypes.reduce(reducer, 0);
            return numOpen > 0;
        }

        /**
         * After clicking "done configuring", wait for other players to join.
         * If you get tired of waiting, you can click "Start anyway" and unassigned players will be AIs.
         * configuration will not be editable while waiting for players to join
         */
        function doneConfiguring() {
            appState.setWaiting();
            updatePlayerConfigButtons();
            updateStartAnywayButton();
            uiCallbacks.setBuildCB(startGame);
        }

        function startGame() {
            convertOpenSlotsToAiPlayersIfNeeded(function() {
                prepareInGameUI();
                erisk.gameRenderer.updateDisplay(gameData.initialGameState);
                appState.setInGame();
                const state = gameData.initialGameState;
                erisk.gameRenderer.showPlayerBanner(state.activePlayer());
                erisk.playOneMove(state);
            });
        }

        // Convert any unassigned open human slots to AI players to allow the game to start.
        function convertOpenSlotsToAiPlayersIfNeeded(callback) {
            const hasOpenSlots = gameData.players.some(player => player.type === CONSTS.PLAYER_HUMAN_OPEN);
            if (hasOpenSlots) {
                convertOpenSlotsToAiPlayers(callback);
            }
            else callback();
        }

        function convertOpenSlotsToAiPlayers(callback) {
            for (let i = 0; i < gameData.players.length; i++) {
                const player = gameData.players[i];
                if (player.type === CONSTS.PLAYER_HUMAN_OPEN && !player.name) {
                    storage.gameSetup.playerTypes[player.originalIndex] = CONSTS.PLAYER_AI;
                }
            }
            regenerateGameDataWithoutNewMap(callback);
        }

        // Callback for player setup buttons. Assigns one of the player types.
        uiCallbacks.setSetupPlayerButtonsCB(function(event) {
            // set the player type for the player
            storage.gameSetup.playerTypes[event.playerIndex] = event.playerTypeIndex;

            updatePlayerConfigButtons();
            updateConfigBottomButtons();
            regenerateGameDataWithoutNewMap();
        });

        // callback for AI config buttons
        uiCallbacks.setSetupAiLevelCB(function(aiLevel) {
            storage.gameSetup.aiLevel = aiLevel;
            updatePlayerConfigButtons();
        });

        uiCallbacks.setSetupTurnCountCB(function(turnCount) {
            storage.gameSetup.turnCount = turnCount;
            updatePlayerConfigButtons();
        });
    }

    function createSetupUI() {
        prepareSetupUI();
        updatePlayerConfigButtons();
        updateConfigBottomButtons();
    }

    // Prepares the whole sidebar on the left for gameplay use.
    function prepareInGameUI() {
        // turn counter
        let html = div({i: 'turn-count', c: 'side-control'});

        // player box area
        html += div({i: 'pd', c: 'side-control user-name'}, gameData.players.map(player => {
            const pid = player.index;
            return div({ i: 'player-box' + pid, c: 'player-box inactive', style: 'background: ' + player.colorEnd },
                player.getPlayerName() +
                div({ c: 'additional-info', i: 'region-count' + pid, tt: 'number of countries owned' }) +
                div({ c: 'additional-info', i: 'player-cash' + pid, tt: 'amount of faith' })
            );
        }).join(''));

        // info box
        html += div({c: 'side-control user-name description', i: 'info'});

        // set it all
        $('game-info').innerHTML = html;

        // show stat box, undo button, and restart game buttons
        ['move-info', 'undo-button', 'restart'].map(domUtils.show);
    }

    function regenerateGameDataWithoutNewMap(callback) {
        regenerateGameData(callback, true);
    }

    function regenerateGameData(callback, keepCurrentMap) {
        if (!isSetupValid()) return;

        google.script.run
            .withSuccessHandler(function(newGameData) {
                gameData.initializeFrom(newGameData);
                erisk.gameRenderer.showMap($('map'), gameData.initialGameState);
                erisk.gameRenderer.updateMapDisplay(gameData.initialGameState);
                if (callback) {
                    callback(newGameData.status);
                }
             })
            .withFailureHandler(showError)
            .makeGameData(storage.gameSetup, gameData.gameId, keepCurrentMap ? gameData.getSimpleObject() : null);
    }

    function updatePlayerConfigButtons() {
        // somebody changed something, so store the new setup
        storage.storeSetup();
        const isWaiting = appState.isWaiting();

        updatePlayerButtons(isWaiting);
        updateAiButtons(isWaiting);
        updateTurnCountButtons(isWaiting);
    }

    function updatePlayerButtons(isWaiting) {
        storage.gameSetup.playerTypes.map(function(playerType, playerIndex) {
            utils.range(0, CONSTS.PLAYER_TYPES.length).map(buttonIndex => {
               updateButton('sb' + playerIndex + buttonIndex, playerType === buttonIndex, isWaiting);
            });

            $('player-box' + playerIndex).querySelector('.player-name').innerHTML =
               CONSTS.PLAYERS[playerIndex].getPlayerName();
        });
    }

    function updateAiButtons(isWaiting) {
        utils.range(0, CONSTS.AI_LEVELS.length).map(function(index) {
            updateButton('ai' + index, index === storage.gameSetup.aiLevel, isWaiting);
        });
    }

    function updateTurnCountButtons(isWaiting) {
        utils.range(0, CONSTS.TURN_COUNTS.length).map(function(index) {
            updateButton('turn-count' + index, CONSTS.TURN_COUNTS[index] === storage.gameSetup.turnCount, isWaiting);
        });
    }


    function updateButton(id, isSelected, isWaiting) {
        domUtils.toggleClass(id, 'selected', isSelected);
        domUtils.toggleClass(id, 'disabled', isWaiting);
        if (isWaiting) {
            domUtils.removeClickOrTap($(id));
        }
    }

    function isSetupValid() {
        let numSetPlayers = 0;
        const enabledPlayers = sequenceUtils.sum(storage.gameSetup.playerTypes, function(playerType) {
            if (playerType === CONSTS.PLAYER_HUMAN_SET) {
                numSetPlayers++;
            }
            return (playerType !== CONSTS.PLAYER_OFF) ? 1 : 0;
        });
        return enabledPlayers > 1 && numSetPlayers > 0;
    }

    function updateConfigBottomButtons() {
        const buttonsDisabled = !isSetupValid();
        erisk.gameRenderer.updateButtons([
            { text: 'Change map', disabled: buttonsDisabled },
            { text: 'Done configuring', disabled: buttonsDisabled,
              tip: 'Click this when done configuring the game at the top'
            },
        ]);
    }

    function updateStartAnywayButton() {
        erisk.gameRenderer.updateButtons([
            { text: 'Start anyway', disabled: false,
              tip: 'If you are tired of waiting for other human players to join, ' +
                   'you can click this and AI players will be used instead'
            },
        ], "Waiting for players to join open slots...");
    }

    // UI to configure the game to be played before it is played
    function prepareSetupUI() {
        createPlayerBoxArea();

        // hide stat box and undo button
        ['move-info', 'undo-button', 'restart'].map(domUtils.hide);

        setupButtonHandlersForPlayerSetupPanel();
    }

    function createPlayerBoxArea() {
        let html = div({c: 'side-control description'}, 'Player setup');
        const playerBoxes = CONSTS.PLAYERS.map(function(player) {
            const pid = player.index;
            return buttonPanel(player.getPlayerName(), 'sb' + player.index, ['Off', 'Set', 'Human', 'AI'], {
                i: 'player-box' + pid,
                c: 'player-box inactive',
                s: 'background: ' + player.colorEnd
            });
        }).join('');
        html += div({i: 'pd', c: 'side-control user-name'}, playerBoxes);
        html += buttonPanel('AI', 'ai', ['Nice', 'Rude', 'Mean', 'Evil']);
        const labels = CONSTS.TURN_COUNTS.map(ct => (ct === CONSTS.UNLIMITED_TURNS) ? 'Endless' : '' + ct);
        html += buttonPanel('Turns', 'turn-count', labels);

        $('game-info').innerHTML = html;
    }

    function buttonPanel(title, buttonIdPrefix, buttonLabels, additionalProperties) {
        const len = buttonLabels.length - 1;
        const buttons = buttonLabels.reverse().map(function(label, index) {
            const id = buttonIdPrefix + (len - index);
            return domUtils.elem('a', {i: id, c: 'right', href: '#', s: 'font-size: 90%'}, label);
        }).join('');
        const properties = {i: buttonIdPrefix, c: 'side-control description', s: 'padding-right: 0.5em'};
        utils.forEachProperty(additionalProperties, function(value, name) {
            properties[name] = value;
        });
        const titleSpan = domUtils.elem('span', {c: 'player-name'}, title);
        return div(properties, titleSpan + buttons);
    }

    function setupButtonHandlersForPlayerSetupPanel() {
        setupButtonHandlersForPlayers();
        setupButtonHandlersForAiType();
        setupButtonHandlersForTurnCount();
    }

    function setupButtonHandlersForPlayers() {
        utils.for2d(0, CONSTS.PLAYERS.length, 0, CONSTS.PLAYER_TYPES.length, function(playerIndex, playerTypeIndex) {
            domUtils.onClickOrTap(
                $('sb' + playerIndex + playerTypeIndex),
                event => uiCallbacks.invokeCallback({ playerIndex, playerTypeIndex }, 'setupPlayerButtons', event)
            );
        });
    }

    function setupButtonHandlersForAiType() {
        utils.range(0, CONSTS.AI_LEVELS.length).map(function(index) {
            domUtils.onClickOrTap(
                $('ai' + index),
                event => uiCallbacks.invokeCallback(index, 'setupAiLevel', event)
            );
        });
    }

    function setupButtonHandlersForTurnCount() {
        utils.range(0, CONSTS.TURN_COUNTS.length).map(function(index) {
            domUtils.onClickOrTap(
                $('turn-count' + index),
                event => uiCallbacks.invokeCallback(CONSTS.TURN_COUNTS[index], 'setupTurnCount', event)
            );
        });
    }

    return my;
}(erisk || {}));
</script>

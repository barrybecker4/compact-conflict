<script>
var erisk = (function(my) {
    const $ = domUtils.$;
    const SERVER_REQUEST_DELAY = 1000;
    let humanMoves = [];

    // Deals with responding to user actions - whether human or AI.
    my.playOneMove = function(state, afterUndo) {
        if (!appState.isInGame())
            return; // game terminated

        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {

            const player = state.activePlayer();

            if (player.name === domUtils.userid()) {
                erisk.uiPickMove(player, state, function(move) {
                    const newState = erisk.makeMove(state, move);
                    move.stateId = newState.id;
                    move.gameId = newState.gameId;
                    if (afterUndo) {
                        humanMoves.pop();
                    }
                    humanMoves.push(move);

                    if (newState.endResult) { // did the game end?
                        showEndGame(newState);
                    } else {
                        erisk.setPreviousState(state.copy()); // only humans can undo
                        setTimeout(() => my.playOneMove(newState), 1); // recursive call
                    }
                });
            } else {
                if (humanMoves.length) {
                    console.log("asking server to append moves: " + humanMoves.map(m => m.stateId));
                    google.script.run
                        .withFailureHandler(showError)
                        .appendGameMoves(humanMoves);
                    humanMoves = [];
                }
                if (player.personality) {
                    erisk.setPreviousState(null); // only humans can undo
                    // request that the computer make the AI moves (and store it in firestore),
                    google.script.run
                        .withFailureHandler(showError)
                        // must wrap state in array to make GAS happy (don't know why)
                        .makeComputerMoves([state], gameData.getSimpleObject());
                }

                // Request from server whatever human or AI moves were made there since last request.
                setTimeout(() => replayMovesFromServer(state), SERVER_REQUEST_DELAY);
            }

            // erisk.gameRenderer.updateDisplay(state);
        });
    }

    function replayMovesFromServer(state) {
        console.log("Requesting replay moves from server starting at state.id = " + state.id);
        google.script.run
            .withSuccessHandler(getPlaybackHandler(state))
            .withFailureHandler(showError)
            .getGameMoves(state.gameId, state.id);
    }

    function getPlaybackHandler(startState) {
        return async function(moves) {

            const finalState = await replayMove(0, startState);

            async function replayMove(i, state) {
                if (i >= moves.length) {
                    return state;
                }
                const theMove = moves[i];
                const move = Move.reconstitute(theMove);
                let nextState = erisk.makeMove(state, move);
                erisk.oneAtaTime(CONSTS.PLAYBACK_DELAY, function() {
                    if (CONSTS.DEBUG)
                        console.log(i + ") aiMove found on server: " + JSON.stringify(move));
                    audio.playSound(CONSTS.SOUNDS.CLICK);
                    erisk.gameRenderer.updateDisplay(nextState);
                });
                return await replayMove(i + 1, nextState);
            }

            if (finalState.endResult) {
                showEndGame(finalState);
            }
            else {
                if (finalState.activePlayer().name !== domUtils.userid()) {
                   // If we have not yet advanced to the player on this client, request more moves until we do
                   setTimeout(() => replayMovesFromServer(finalState), SERVER_REQUEST_DELAY);
                }
                else setTimeout(() => my.playOneMove(finalState), 1);
            }
        }
    }

    function showEndGame(state) {
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, () => erisk.gameRenderer.updateDisplay(state));
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {
            const winner = state.endResult;
            const delay = 200;
            const duration = 4000;
            if (winner !== CONSTS.DRAWN_GAME) {
                erisk.gameRenderer.showBanner(winner.colorEnd, winner.name + " wins the game!", delay, duration);
            } else {
                erisk.gameRenderer.showBanner('#333', "The game ends in a draw!", delay, duration);
            }

            erisk.gameRenderer.updateDisplay(state);

            $('turn-count').innerHTML = "Game complete";
            const infoEl = $('info');
            infoEl.innerHTML = domUtils.elem('p', {}, "Click the button below to start a new game.");
            infoEl.style.background = '#555';
            $('move-info').style.display = 'none';
            erisk.gameRenderer.updateButtons([ {text: "New game"} ]);

            uiCallbacks.setBuildCB(erisk.runSetupScreen);
        });
    }

    return my;
}(erisk || {}));
</script>
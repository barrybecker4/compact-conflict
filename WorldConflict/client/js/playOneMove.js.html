<script>
var erisk = (function(my) {
    const $ = domUtils.$;
    const SERVER_REQUEST_DELAY = 1000;
    var humanStates = [];

    // Deals with responding to user actions - whether human or AI.
    my.playOneMove = function(state) {
        if (!appState.isInGame())
            return; // game terminated

        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {

            const player = state.activePlayer();

            //  player changed from human to AI or vv
            //  later this will look for the transition from the player on this client and everyone else.
            if (!state.prevPlayer() || player.personality != state.prevPlayer().personality) {
                if (humanStates.length) {
                    google.script.run
                        .withFailureHandler(showError)
                        .appendGameStates(humanStates);
                }
                if (player.personality) {
                    // request that the computer make the AI move (and store it in firestore),
                    console.log("Now requesting AI moves from server for state.id = " + state.id + " and player " + player.name);
                    google.script.run
                        .withFailureHandler(showError)
                        // must wrap state in array to make GAS happy (don't know why)
                        .makeComputerMoves([state], gameData.getSimpleObject());
                }
                humanStates = [];
            }

            if (!player.personality) {
                erisk.uiPickMove(player, state, function(move) {
                    const newState = erisk.makeMove(state, move);
                    newState.moveDecision = move; // here?
                    humanStates.push(newState);

                    if (newState.endResult) { // did the game end?
                        showEndGame(newState);
                        return;
                    } else {
                        erisk.setPreviousState(state.copy()); // only humans can undo
                        setTimeout(() => my.playOneMove(newState), 1); // recursive call
                    }
                });
            } else {
                // after a small delay, request from server whatever moves were made there since last request.
                setTimeout(() => replayMovesFromServer(state), SERVER_REQUEST_DELAY);
            }

            erisk.gameRenderer.updateDisplay(state);
        });
    }

    function replayMovesFromServer(state) {
        console.log("Requesting replay moves from server starting at state.id = " + state.id);
        google.script.run
            .withSuccessHandler(async function(moves) {

                const finalState = await replayMove(0, state);
                // erisk.gameRenderer.updateDisplay(finalState);

                async function replayMove(i, newState) {
                    if (i >= moves.length) {
                        return newState;
                    }
                    const theMove = moves[i];
                    const move = Move.reconstitute(theMove);
                    console.log(i + ") aiMove found on server: " + JSON.stringify(move));
                    audio.playSound(CONSTS.SOUNDS.CLICK);
                    const nextState = erisk.makeMove(newState, move);
                    // nextState.moveDecision = move; // here?
                    erisk.gameRenderer.updateDisplay(nextState);
                    await utils.sleep(CONSTS.MOVE_DELAY);
                    return await replayMove(i + 1, nextState);
                }

                if (finalState.endResult) {
                    showEndGame(finalState);
                }
                else {
                    if (finalState.activePlayer().personality) {
                       // If we have not yet advanced to the next (human) player, request more moves until we do
                       setTimeout(() => replayMovesFromServer(finalState), SERVER_REQUEST_DELAY);
                    }
                    else setTimeout(() => my.playOneMove(finalState), 1);
                }
            })
            .withFailureHandler(showError)
            .getGameMoves(state.gameId, state.id);
    }

    function showEndGame(state) {
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, () => erisk.gameRenderer.updateDisplay(state));
        erisk.oneAtaTime(CONSTS.MOVE_DELAY, function() {
            const winner = state.endResult;
            const delay = 200;
            const duration = 4000;
            if (winner != CONSTS.DRAWN_GAME) {
                erisk.gameRenderer.showBanner(winner.colorEnd, winner.name + " wins the game!", delay, duration);
            } else {
                erisk.gameRenderer.showBanner('#333', "The game ends in a draw!", delay, duration);
            }

            erisk.gameRenderer.updateDisplay(state);

            $('turn-count').innerHTML = "Game complete";
            $('info').innerHTML = domUtils.elem('p', {}, "Click the button below to start a new game.");
            $('info').style.background = '#555';
            $('move-info').style.display = 'none';
            erisk.gameRenderer.updateButtons([ {text: "New game"} ]);

            uiCallbacks.setBuildCB(erisk.runSetupScreen);
        });
    }

    return my;
}(erisk || {}));
</script>